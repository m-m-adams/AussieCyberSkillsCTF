#given
p = 12734388423027263805838082500461676978623655379040968520546499300029960167301383167850280748975051651068956429007977575788319730260224838735906264562353439
n = 157702448005359477880276703881417542766532271253898875144862237295534389932645745440321314344155006452901850061218324448819794756811585710920483305991839897576379274096843671700056818985381443851522309502756962982643477863379848745589903319467057931521291676300705108088925310179888766286840665670847263918883
dp = 1629060793475490480491257822431675546655352945988236510811909662431004199718969287583651914413083490683498510457797851859478614033704655589108492682438851
dq = 12227193374836295874914734134031856482048035132747011764775087199614504058144119398173840633051109632277020599101180303368183175685607695352733721054594185
ciphertext = 2772489103574256916589355598352984637133379420683868695844414660224066164318649503538506201722675335765654507693505334172444759158147405197592907812468946259847512311022873479280679452528934139985201980872078942452333918885852846723140468867419436995385882106451105552819843322739530018360135415554236743751

#derived
q = 12383982863298738204036450420319386406456344897208429324304778703518027931860767965960751245832467424825926372335499256792054831897195091136923192334652797
q = n//p

print(q)

import binascii
import struct

# return (g, x, y) a*x + b*y = gcd(x, y)
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, x, y = egcd(b % a, a)
        return (g, y - (b // a) * x, x)

def decryptRSA(p,q,e,ct):
    # compute n
    n = p * q
    phi = (p - 1) * (q - 1)	
    gcd, a, b = egcd(e, phi)
    d = a
    print ("d: " + str(d))
    pt = pow(ct, d, n)
    return pt

def encryptRSA(p,q,e,pt):
    # compute n
    n = p * q
    phi = (p - 1) * (q - 1)
    gcd, a, b = egcd(e, phi)
    d = a
    print ("d: " + str(d))
    ct = pow(pt, e, n)
    return ct


def convert(int_value):
   encoded = format(int_value, 'x')
   length = len(encoded)
   encoded = encoded.zfill(length+length%2)
   return encoded.decode('hex')

# x = mulinv(b) mod n, (x * b) % n == 1
def mulinv(b, n):
    g, x, _ = egcd(b, n)
    if g == 1:
        return x % n

def main():
    # By implementing Chinese remainder algorithm
    # 1) p and q are the primes
    # 2) dp = d mod (p - 1)
    # 3) dq = d mod (q - 1)
    # 4) Qinv = 1/q mod p *This is not integer devision but multiplicative inverse
    # 5) m1 = pow(c, dp, p)
    # 6) m2 = pow(c, dq, q)
    # 7-1) h = Qinv(m1 - m2) mod p  ; if m1 < m2
    # 7-2) h = Qinv * (m1 + q/p) 
    # 8) m = m2 + hq

    # m = 65
    # p = 61
    # q = 53
    # dp = 53
    # dq = 49
    # c = 2790

    p = 12734388423027263805838082500461676978623655379040968520546499300029960167301383167850280748975051651068956429007977575788319730260224838735906264562353439
    n = 157702448005359477880276703881417542766532271253898875144862237295534389932645745440321314344155006452901850061218324448819794756811585710920483305991839897576379274096843671700056818985381443851522309502756962982643477863379848745589903319467057931521291676300705108088925310179888766286840665670847263918883
    dp = 1629060793475490480491257822431675546655352945988236510811909662431004199718969287583651914413083490683498510457797851859478614033704655589108492682438851
    dq = 12227193374836295874914734134031856482048035132747011764775087199614504058144119398173840633051109632277020599101180303368183175685607695352733721054594185
    c = 2772489103574256916589355598352984637133379420683868695844414660224066164318649503538506201722675335765654507693505334172444759158147405197592907812468946259847512311022873479280679452528934139985201980872078942452333918885852846723140468867419436995385882106451105552819843322739530018360135415554236743751

    #derived
    q = 12383982863298738204036450420319386406456344897208429324304778703518027931860767965960751245832467424825926372335499256792054831897195091136923192334652797

    Qinv = mulinv(q,p)
    print ("Qinv: " + str(Qinv))

    m1 = pow(c, dp, p)
    print ("m1: " + str(m1))

    m2 = pow(c, dq, q)
    print ("m2: " + str(m2))

    h = (Qinv * (m1 - m2)) % p
    print ("h: " + str(h))

    m = m2 + (h*q)
    print ("m: " + str(int(m)))

    hexadecimals = str(hex(m))[2:]
    print(hexadecimals)
    print ("solved: " + str(binascii.unhexlify(hexadecimals)))
    # solved: Theres_more_than_one_way_to_RSA

if __name__ == "__main__":
    main()